<?php
/**
 * ObjectSerializer 
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace App\apiModels;

/**
 * ObjectSerializer Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client 
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ObjectSerializer
{

    /**
     * Build a JSON POST object
     *
     * @param mixed $data the data to serialize
     *
     * @return string serialized form of $data
     */
    public function sanitizeForSerialization($data)
    {
        if (is_scalar($data) || null === $data) {
            $sanitized = $data;
        } else if ($data instanceof \DateTime) {
            $sanitized = $data->format(\DateTime::ISO8601);
        } else if (is_array($data)) {
            foreach ($data as $property => $value) {
                $data[$property] = $this->sanitizeForSerialization($value);
            }
            $sanitized = $data;
        } else if (is_object($data)) {
            $values = array();
            foreach (array_keys($data::$swaggerTypes) as $property) {
                $getter = $data::$getters[$property];
                if ($data->$getter() !== null) {
                    $values[$data::$attributeMap[$property]] = $this->sanitizeForSerialization($data->$getter());
                }
            }
            $sanitized = $values;
        } else {
            $sanitized = (string)$data;
        }

        return $sanitized;
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the path, by url-encoding.
     *
     * @param string $value a string which will be part of the path
     *
     * @return string the serialized object
     */
    public function toPathValue($value)
    {
        return rawurlencode($this->toString($value));
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the query, by imploding comma-separated if it's an object.
     * If it's a string, pass through unchanged. It will be url-encoded
     * later.
     *
     * @param object $object an object to be serialized to a string
     *
     * @return string the serialized object
     */
    public function toQueryValue($object)
    {
        if (is_array($object)) {
            return implode(',', $object);
        } else {
            return $this->toString($object);
        }
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the header. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string $value a string which will be part of the header
     *
     * @return string the header string
     */
    public function toHeaderValue($value)
    {
        return $this->toString($value);
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the http body (form parameter). If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string $value the value of the form parameter
     *
     * @return string the form string
     */
    public function toFormValue($value)
    {
        if ($value instanceof SplFileObject) {
            return $value->getRealPath();
        } else {
            return $this->toString($value);
        }
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the parameter. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string $value the value of the parameter
     *
     * @return string the header string
     */
    public function toString($value)
    {
        if ($value instanceof \DateTime) { // datetime in ISO8601 format
            return $value->format(\DateTime::ISO8601);
        } else {
            return $value;
        }
    }

    /**
     * Deserialize a JSON string into an object
     *
     * @param mixed  $data       object or primitive to be deserialized
     * @param string $class      class name is passed as a string
     * @param string $httpHeader HTTP headers
     *
     * @return object an instance of $class
     */
    public function deserialize($data, $class, $httpHeader = null, $validate = true)
    {
        if (null === $data) {
            app('log')->Debug("Deserializuję jako null");
            $deserialized = null;
        } elseif (substr($class, 0, 4) === 'map[') { // for associative array e.g. map[string,int]
            app('log')->Debug("Deserializuję jako tablicę asocjacyjną");
            $inner = substr($class, 4, -1);
            $deserialized = array();
            if (strrpos($inner, ",") !== false) {
                $subClass_array = explode(',', $inner, 2);
                $subClass = $subClass_array[1];
                foreach ($data as $key => $value) {
                    $deserialized[$key] = $this->deserialize($value, $subClass, $httpHeader, $validate);
                }
            }
        } elseif (strcasecmp(substr($class, -2), '[]') == 0) {
            app('log')->Debug("Deserializuję jako tablicę");
            $subClass = substr($class, 0, -2);
            $values = array();
            foreach ($data as $key => $value) {
                $values[] = $this->deserialize($value, $subClass, $httpHeader, $validate);
            }
            $deserialized = $values;
        } elseif ($class === '\DateTime') {
            app('log')->Debug("Deserializuję jako DateTime");
            $deserialized = new \Carbon\Carbon($data);
        } elseif (in_array($class, array('void', 'bool', 'string', 'double', 'byte', 'mixed', 'integer', 'float', 'int', 'DateTime', 'number', 'boolean', 'object'))) {
            app('log')->Debug("Deserializuję jako typ podstawowy: $class");
            settype($data, $class);
            $deserialized = $data;
        } elseif ($class === '\SplFileObject') {
            app('log')->Debug("Deserializuję jako plik");
            // determine file name
            if (preg_match('/Content-Disposition: inline; filename=[\'"]?([^\'"\s]+)[\'"]?$/i', $httpHeader, $match)) {
                $filename = Configuration::getDefaultConfiguration()->getTempFolderPath().$match[1];
            } else {
                $filename = tempnam(Configuration::getDefaultConfiguration()->getTempFolderPath(), '');
            }
            $deserialized = new \SplFileObject($filename, "w");
            $byte_written = $deserialized->fwrite($data);
            error_log("[INFO] Written $byte_written byte to $filename. Please move the file to a proper folder or delete the temp file after processing.\n", 3, Configuration::getDefaultConfiguration()->getDebugFile());
      
        } else {
            app('log')->Debug("Deserializuję jako obiekt klasy: $class");
            $data = (object)$data;
            if(!isset($data->val)){
                if(isset($data->scalar)){
                    $data->val = $data->scalar;
                    unset($data->scalar);
                }
                if(isset($data->string)){
                    $data->val = $data->string;
                    unset($data->string);
                }
            }
            $classImplementation = str_replace('prototypes', 'implementations', $class).'_impl';
            $instance = new $classImplementation();
            foreach ($instance::$swaggerTypes as $property => $type) {
                $propertySetter = $instance::$setters[$property];
/*                
echo '++++++++++++++'.$classImplementation.' '.__LINE__.' '.$propertySetter."<br>\n";
echo $property."|<br>\n";
echo '$propertySetter: '.print_r(isset($propertySetter),1)."|<br>\n";
echo '$data: '.print_r(isset($data->{$instance::$attributeMap[$property]}),1)."|<br>\n";
echo '$data: '.print_r($data,1).' '.$instance::$attributeMap[$property]."|<br>\n";
//*/
                if (!isset($propertySetter) || !isset($data->{$instance::$attributeMap[$property]})) {
/*
echo 'KONIEC '.$classImplementation."<br><br>\n";
echo '$data: '.print_r($data,1).' '.$instance::$attributeMap[$property]."|<br>\n";
//*/
                    continue;
                }
                
                $propertyValue = $data->{$instance::$attributeMap[$property]};
                
//echo $type.' : '.print_r($propertyValue,1).$propertySetter."<br><br>\n";

                if (isset($propertyValue)) {
                    $instance->$propertySetter($this->deserialize($propertyValue, $type, $httpHeader, $validate));
                    
                }
            }
            $deserialized = $instance;
        }

        if ($validate && is_subclass_of($deserialized, 'App\apiModels\ApiModel')) {
            $errorClass = env('ERROR_MODEL_IMPL_TRAVEL_V1');
            $deserialized->validate($errorClass);
        }
     
        return $deserialized;
    }
}
